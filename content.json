{"meta":{"title":"KAOLA's note","subtitle":"fix it","description":null,"author":"KAOLA","url":"http://blog.kaolagogogo.fun","root":"/"},"pages":[{"title":"","date":"2019-05-01T10:14:27.305Z","updated":"2019-05-01T10:14:27.305Z","comments":true,"path":"about/index.html","permalink":"http://blog.kaolagogogo.fun/about/index.html","excerpt":"","text":"哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 我有自己的博客啦 一定要开发出好看的自己能用的工具类App 立帖为证！！"}],"posts":[{"title":"锁","slug":"锁","date":"2019-04-28T13:30:32.000Z","updated":"2019-05-06T12:53:07.328Z","comments":true,"path":"2019/04/28/锁/","link":"","permalink":"http://blog.kaolagogogo.fun/2019/04/28/锁/","excerpt":"","text":"什么是锁锁是保证线程安全的手段，保证临界区的代码同一时间只能有一个线程执行，使得类的行为和规范一致。 使用场景我们常用锁来避免多线程引起的资源竞争等问题 definitions wikipedia 临界区:一块对公共资源进行访问的代码，并非一种机制或是算法 自旋锁(spinlock):do while 忙等待 优点是避免了上下文调度开销 缺点是耗CPU 只适合段时间的任务 互斥锁(mutexlock) 休眠状态等锁 读写锁(rwlock)： 处于“写锁”时任何操作都要休眠等锁 递归锁(recursivelock)：是互斥锁的一个特例 允许同一个线程在未释放拥有的锁时反复对该锁进行加锁操作 信号量（semaphore） 互斥锁可以看成是semaphore在仅取值0/1时的特例。信号量更高级，可以实现更复杂的需求，不仅限于解决多线程同步问题。 条件锁 顾名思义 控制了锁的变量，只有满足条件时，锁才会打开 死锁 一个资源被多次调用，而多次调用方都未能释放该资源就会造成一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死 锁状态或系统产生了死锁。 iOS中常见的锁类型1. @synchronized### 解释 关键字加锁 是互斥锁的一种 ### 特点 用法简洁、可读性强：传入对象即可，没有显示的添加锁、释放锁代码 ### 使用 123@synchronized(obj)&#123; // do work &#125; 杨肖玉的博客中翻译了国外大神的文章并做了详细的解释，对下面的问题有很详细的解读，博客地址：http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/ ### 问题 1. 锁是如何传入@synchronized的对象关联上的? 2. 如果传入@synchronized的对象在@synchronized的block里面被释放或者被赋值为nil会怎样? 下面是阅读完博客后的笔记。 首先 [apple文档](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3)中有一段话： &gt;As a precautionary measure, the @synchronized block implicitly adds an exception handler to the protected code. This handler automatically releases the mutex in the event that an exception is thrown. This means that in order to use the @synchronized directive, you must also enable Objective-C exception handling in your code. If you do not want the additional overhead caused by the implicit exception handler, you should consider using the lock classes. &gt;其中`the @synchronized block implicitly adds an exception handler to the protected code` 意思是@synchronized为代码块为隐式地添加了一个异常处理。 `@synchronized` block 会变成 `objc_sync_enter` 和 `objc_sync_exit` 的成对儿调用 可以理解成上面的代码转化成了下面这样： 12345678910@synchronized(obj)&#123; // do work &#125; @try &#123; objc_sync_enter(obj); // do work &#125; @finally &#123; objc_sync_exit(obj); &#125; ### 带着问题看源码 [最新源码地址](https://opensource.apple.com/source/objc4/objc4-750/runtime/objc-sync.mm.auto.html) `&lt;objc/objc-sync.h&gt;`中： 12345678910111213141516171819202122232425262728293031323334typedef struct alignas(CacheLineSize) SyncData &#123; struct SyncData* nextData; DisguisedPtr&lt;objc_object&gt; object; int32_t threadCount; // number of THREADS using this block recursive_mutex_t mutex;&#125; SyncData;typedef struct &#123; SyncData *data; unsigned int lockCount; // number of times THIS THREAD locked this block&#125; SyncCacheItem;typedef struct SyncCache &#123; unsigned int allocated; unsigned int used; SyncCacheItem list[0];&#125; SyncCache;/*Fast cache: two fixed pthread keys store a single SyncCacheItem. This avoids malloc of the SyncCache for threads that only synchronize a single object at a time.SYNC_DATA_DIRECT_KEY == SyncCacheItem.dataSYNC_COUNT_DIRECT_KEY == SyncCacheItem.lockCount*/struct SyncList &#123; SyncData *data; spinlock_t lock; constexpr SyncList() : data(nil), lock(fork_unsafe_lock) &#123; &#125;&#125;;// Use multiple parallel lists to decrease contention among unrelated objects.#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock#define LIST_FOR_OBJ(obj) sDataLists[obj].datastatic StripedMap&lt;SyncList&gt; sDataLists; `SyncList`可以看成是一个链表（key是对象地址的hash值），`SyncData`是链表中的某个节点。 `SyncData`包括了`object`（就是我们传入的对象）、`nextData`（链表中的下一个节点）、`recursive_mutex_t`类型（递归锁）的`mutex`（与之关联的一个互斥锁）、`threadCount`（被使用的线程的数量） `objc_sync_enter` 123456789101112131415161718int objc_sync_enter(id obj)&#123; int result = OBJC_SYNC_SUCCESS; if (obj) &#123; SyncData* data = id2data(obj, ACQUIRE); assert(data); data-&gt;mutex.lock(); &#125; else &#123; // @synchronized(nil) does nothing if (DebugNilSync) &#123; _objc_inform(\"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug\"); &#125; objc_sync_nil(); &#125; return result;&#125; 1. 首先回答如果obj为nil的情况 ：`@synchronized(nil) does nothing` `objc_sync_nil` 什么也不做 2. obj不为空： 调用`id2data`取出obj对应的SyncData，判断之后进行加锁操作 `objc_sync_exit` 123456789101112131415161718192021int objc_sync_exit(id obj)&#123; int result = OBJC_SYNC_SUCCESS; if (obj) &#123; SyncData* data = id2data(obj, RELEASE); if (!data) &#123; result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; &#125; else &#123; bool okay = data-&gt;mutex.tryUnlock(); if (!okay) &#123; result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; &#125; &#125; &#125; else &#123; // @synchronized(nil) does nothing &#125; return result;&#125; 1. 惯例回答 如果代码执行完是，obj为nil： `@synchronized(nil) does nothing` 2. obj不为空： 调用`id2data`取出obj对应的SyncData，判断之后进行解锁操作 那么`id2data`在传入了`obj` 加锁解锁时，函数内部具体做了什么呢？ `id2data`代码比较长，为了方便阅读，直接将笔记写在里面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191static SyncData* id2data(id object, enum usage why)&#123; spinlock_t *lockp = &amp;LOCK_FOR_OBJ(object);//lockp指向SyncList对象中的自旋锁 SyncData **listp = &amp;LIST_FOR_OBJ(object);//listp指向SyncList链表 SyncData* result = NULL;//对于同一个线程来说，有两种缓存方式： //第一种：快速缓存（fastCache），适用于一个线程一次只对一个对象加锁的情况，用宏SUPPORT_DIRECT_THREAD_KEYS来标识 //这种情况意味着同一时间内，线程缓存中只有一个SyncCacheItem对象，键值SYNC_DATA_DIRECT_KEY和SYNC_COUNT_DIRECT_KEY分别对应SyncCacheItem结构体中的SyncData对象和lockCount.#if SUPPORT_DIRECT_THREAD_KEYS // Check per-thread single-entry fast cache for matching object // 用于标识当前线程的是否已使用fastCache bool fastCacheOccupied = NO; SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);//获取syncdata if (data) &#123; fastCacheOccupied = YES;//标识fastcache被使用 if (data-&gt;object == object) &#123;//判断fastcache中SyncData中的object与当前的对象是否一致// Found a match in fast cache. uintptr_t lockCount; result = data; lockCount = (uintptr_t)tls_get_direct(SYNC_COUNT_DIRECT_KEY);//获取当前线程中SyncData对象已经加锁的次数 if (result-&gt;threadCount &lt;= 0 || lockCount &lt;= 0) &#123; _objc_fatal(\"id2data fastcache is buggy\");//对象发生错误 &#125; switch(why) &#123;//判断当前的操作是加锁还是解锁 case ACQUIRE: &#123;//加锁 然后更新 lockCount++; tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)lockCount); break; &#125; case RELEASE://解锁 lockCount--; tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)lockCount); if (lockCount == 0) &#123;//如果lockCount为零 // remove from fast cache //将对应的SyncData对象从线程缓存中移除 tls_set_direct(SYNC_DATA_DIRECT_KEY, NULL); // atomic because may collide with concurrent ACQUIRE //原子操作 确保线程安全 OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount); //threadCount是多个线程共享的变量，用于记录对一个对象加锁的线程个数，threadCount对应的SyncData对象除了线程缓存中持有之外，还存在于全局哈希表sDataLists中，sDataLists哈希表是多个线程共享的数据结构，因此存在多线程访问的可能，因此需要加锁；而lockCount则与线程一一对应且存储在线程的缓存区中，不存在多线性读写问题，因此不需要加锁 &#125; break; case CHECK: // do nothing break; &#125; return result; &#125; &#125;#endif // Check per-thread cache of already-owned locks for matching object // Check per-thread cache of already-owned locks for matching object //这是第二种缓存方式：使用SyncCache结构体来维护一个SyncCacheItem数组，这样一个线程就可以处理对多个同步对象。值得注意的是SyncCache与线程也是一对一的关系。 SyncCache *cache = fetch_cache(NO); //获取当前线程缓存区中的SyncCache对象 if (cache) &#123; unsigned int i; //遍历SyncCache对象中的SyncCacheItem数组，匹配当前同步对象object for (i = 0; i &lt; cache-&gt;used; i++) &#123; SyncCacheItem *item = &amp;cache-&gt;list[i]; if (item-&gt;data-&gt;object != object) continue; // Found a match. 匹配到了 result = item-&gt;data; if (result-&gt;threadCount &lt;= 0 || item-&gt;lockCount &lt;= 0) &#123; _objc_fatal(\"id2data cache is buggy\"); &#125; switch(why) &#123; //同上fast-cache一样 case ACQUIRE: item-&gt;lockCount++; break; case RELEASE: item-&gt;lockCount--; if (item-&gt;lockCount == 0) &#123; // remove from per-thread cache cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used]; // atomic because may collide with concurrent ACQUIRE OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount); &#125; break; case CHECK: // do nothing break; &#125; return result; &#125; &#125; // Thread cache didn't find anything. // Walk in-use list looking for matching object // Spinlock prevents multiple threads from creating multiple // locks for the same new object. // We could keep the nodes in some hash table if we find that there are // more than 20 or so distinct locks active, but we don't do that now. //如果当前线程中的缓存中没有找到当前同步对象对应的SyncData对象，则在全局哈希表中查找//因为全局哈希表是多个线程共享的数据结构，因此需要进行加锁处理 lockp-&gt;lock(); &#123; SyncData* p; SyncData* firstUnused = NULL;//遍历当前同步对象obejct在全局哈希表中的SyncData链表。这里之所以使用链表，是因为哈希表的hash算法不能确保hash的唯一性，存在多个对象对应一个hash值的情况。 for (p = *listp; p != NULL; p = p-&gt;nextData) &#123; if ( p-&gt;object == object ) &#123;//匹配到了 result = p; // atomic because may collide with concurrent RELEASE OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);//原子操作 goto done; &#125; if ( (firstUnused == NULL) &amp;&amp; (p-&gt;threadCount == 0) )//标记空闲对象 firstUnused = p; &#125; // no SyncData currently associated with object//由于此时同步对象object没有对应的SyncData对象，因此RELEASE与CHECK都属于无效操作 if ( (why == RELEASE) || (why == CHECK) ) goto done; // an unused one was found, use it//如果没有找到匹配的SyncData对象且存在空闲的SyncData对象，则直接使用，不需要创建新的SyncData，以提高效率。 if ( firstUnused != NULL ) &#123; result = firstUnused; result-&gt;object = (objc_object *)object; result-&gt;threadCount = 1; goto done; &#125; &#125; // Allocate a new SyncData and add to list. // XXX allocating memory with a global lock held is bad practice, // might be worth releasing the lock, allocating, and searching again. // But since we never free these guys we won't be stuck in allocation very often.//新建一个SyncData对象 posix_memalign((void **)&amp;result, alignof(SyncData), sizeof(SyncData)); result-&gt;object = (objc_object *)object; result-&gt;threadCount = 1; new (&amp;result-&gt;mutex) recursive_mutex_t(fork_unsafe_lock); result-&gt;nextData = *listp; *listp = result; done://对全局哈希表的操作结束，解锁 lockp-&gt;unlock(); if (result) &#123; // Only new ACQUIRE should get here. // All RELEASE and CHECK and recursive ACQUIRE are // handled by the per-thread caches above. if (why == RELEASE) &#123; // Probably some thread is incorrectly exiting // while the object is held by another thread. return nil; &#125; if (why != ACQUIRE) _objc_fatal(\"id2data is buggy\"); if (result-&gt;object != object) _objc_fatal(\"id2data is buggy\");#if SUPPORT_DIRECT_THREAD_KEYS if (!fastCacheOccupied) &#123; // Save in fast thread cache //直接缓存新建的SyncData对象 tls_set_direct(SYNC_DATA_DIRECT_KEY, result); tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)1); &#125; else #endif &#123; // Save in thread cache if (!cache) cache = fetch_cache(YES); cache-&gt;list[cache-&gt;used].data = result; cache-&gt;list[cache-&gt;used].lockCount = 1; cache-&gt;used++; &#125; &#125; return result;&#125; 2. dispatch_once### 解释 dispatch_once 顾名思义 只执行一次，单例常用dispatch_once来保证某个单例 ### 特点 用法简洁 适用于只执行一次任务的场景 ### 使用 dispatch_once的用法： 1234static dispatch_once_t predicate;dispatch_once(&amp;predicate, ^&#123; // one time task&#125;); ### 问题 Q1:dispatch_once是如何保证任务只执行一次的？ Q2:使用dispatch_once后，怎么做到重新初始化？ ### 带着问题看源码 * [once.h](https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/dispatch/once.h.auto.html) * [once.c](https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/src/once.c.auto.html) #### dispatch_once参数 1234567891011121314151617/*! * @function dispatch_once * * @abstract * Execute a block once and only once. * block近执行一次 * @param predicate * A pointer to a dispatch_once_t that is used to test whether the block has * completed or not. * predicate是一个dispatch_once_t类型的用来判断block是否执行完毕的指针 * @param block * The block to execute once. * block参数是执行的一次的任务 * @discussion * Always call dispatch_once() before using or testing any variables that are * initialized by the block. */ #### dispatch_once内部调用顺序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081_dispatch_once(dispatch_once_t *predicate, DISPATCH_NOESCAPE dispatch_block_t block)&#123; if (DISPATCH_EXPECT(*predicate, ~0l) != ~0l) &#123;//判断predicate是否为DISPATCH_ONCE_DONE 如果没有done dispatch_once(predicate, block); &#125; else &#123; dispatch_compiler_barrier();//barrier??? &#125; DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~0l);&#125;dispatch_once(dispatch_once_t *val, dispatch_block_t block)&#123; dispatch_once_f(val, block, _dispatch_Block_invoke(block));&#125;dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)&#123;#if !DISPATCH_ONCE_INLINE_FASTPATH if (likely(os_atomic_load(val, acquire) == DLOCK_ONCE_DONE)) &#123; return; &#125;#endif // !DISPATCH_ONCE_INLINE_FASTPATH return dispatch_once_f_slow(val, ctxt, func);&#125;dispatch_once_f_slow(dispatch_once_t *val, void *ctxt, dispatch_function_t func)&#123;//重点#if DISPATCH_GATE_USE_FOR_DISPATCH_ONCE dispatch_once_gate_t l = (dispatch_once_gate_t)val;//将传进来的参数强制转换成dispatch_once_gate_t if (_dispatch_once_gate_tryenter(l)) &#123; _dispatch_client_callout(ctxt, func);//执行block _dispatch_once_gate_broadcast(l);//发广播 &#125; else &#123; _dispatch_once_gate_wait(l);//等待 &#125;#else _dispatch_once_waiter_t volatile *vval = (_dispatch_once_waiter_t*)val; struct _dispatch_once_waiter_s dow = &#123; &#125;; _dispatch_once_waiter_t tail = &amp;dow, next, tmp; dispatch_thread_event_t event; if (os_atomic_cmpxchg(vval, NULL, tail, acquire)) &#123;//os_atomic_cmpxchgv：原子操作 判断vval是否为NULL dow.dow_thread = _dispatch_tid_self(); _dispatch_client_callout(ctxt, func);//执行block next = (_dispatch_once_waiter_t)_dispatch_once_xchg_done(val); while (next != tail) &#123; tmp = (_dispatch_once_waiter_t)_dispatch_wait_until(next-&gt;dow_next); event = &amp;next-&gt;dow_event; next = tmp; _dispatch_thread_event_signal(event); &#125; &#125; else &#123; _dispatch_thread_event_init(&amp;dow.dow_event); next = *vval; for (;;) &#123;//遍历每一个后续的请求 if (next == DISPATCH_ONCE_DONE) &#123;//判断是否完成 如果完成则判断下一个 break; &#125; //没有完成 将相应的请求添加到链表中 if (os_atomic_cmpxchgv(vval, next, tail, &amp;next, release)) &#123; //os_atomic_cmpxchgv：原子操作 比较vval与next 如果相等，返回true 并设置vval=tail 不相等 返回false 并设置vval=next 由上可知 第一次进入该循环 应该返回true dow.dow_thread = next-&gt;dow_thread; dow.dow_next = next; if (dow.dow_thread) &#123; pthread_priority_t pp = _dispatch_get_priority(); _dispatch_thread_override_start(dow.dow_thread, pp, val); &#125; _dispatch_thread_event_wait(&amp;dow.dow_event); if (dow.dow_thread) &#123; _dispatch_thread_override_end(dow.dow_thread, val); &#125; break; &#125; &#125; _dispatch_thread_event_destroy(&amp;dow.dow_event); &#125;#endif&#125; 2. NSLock### 解释 NSLock是Foundation框架中封装好的互斥锁， ### 使用 (伪代码) 1234....init yourlock...[yourlock lock];//执行前锁住...yourtask....[yourloxk unlock];//完成后需要解锁 特点问题带着问题看源码3. NSCondition### 解释 条件锁 ### 使用 ### 特点 ### 问题 ### 带着问题看源码 4. NSConditionLock### 解释 条件锁 ### 特点 ### 使用 ### 问题 ### 带着问题看源码 5. NSRecursiveLock### 解释 递归锁 ### 特点 ### 使用 ### 问题 ### 带着问题看源码 6. pthread_mutex### 解释 互斥锁、也支持递归 ### 特点 ### 使用 ### 问题 ### 带着问题看源码 7. dispatch_semaphore 信号量### 解释 ### 特点 ### 使用 ### 问题 ### 带着问题看源码 8. dispatch_async_barrier 读写锁### 解释 ### 特点 ### 使用 ### 问题 ### 带着问题看源码 9. OSSpinLock### 解释 ### 特点 ### 使用 ### 问题 ### 带着问题看源码 10. pthread_rwlock### 解释 ### 特点 ### 使用 ### 问题 ### 带着问题看源码 11. POSIX Conditions### 解释 ### 特点 ### 使用 ### 问题 ### 带着问题看源码 12. os_unfair_lock### 解释 ### 特点 ### 使用 ### 问题 ### 带着问题看源码 总结 锁 特点(优势) 说明 @synchronized dispatch_once NSLock","categories":[],"tags":[]},{"title":"weak","slug":"weak","date":"2018-11-25T16:52:05.000Z","updated":"2019-05-01T10:14:27.302Z","comments":true,"path":"2018/11/26/weak/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/weak/","excerpt":"","text":"why一般情况下，weak修饰对象，assign修饰基本数据类型。 weak和assign，并不会增加对象的rc assign修饰的对象，出栈后，对象所指向的内存块极有可能被回收，如果此时再访问指针，会出现野指针的情况 weak修饰的对象，因为weak所修饰的对象被系统回收之后，指针会被置为nil，不会出现也指针 下面会从源码中一探究竟。（源码的版本是objc4-723）\bweak 源码源码中出现的数据结构 SideTables 123static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);&#125; SideTable 123456789101112131415161718192021222324struct SideTable &#123; spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; SideTable() &#123; memset(&amp;weak_table, 0, sizeof(weak_table)); &#125; ~SideTable() &#123; _objc_fatal(\"Do not delete SideTable.\"); &#125; void lock() &#123; slock.lock(); &#125; void unlock() &#123; slock.unlock(); &#125; void forceReset() &#123; slock.forceReset(); &#125; // Address-ordered lock discipline for a pair of side tables. template&lt;HaveOld, HaveNew&gt; static void lockTwo(SideTable *lock1, SideTable *lock2); template&lt;HaveOld, HaveNew&gt; static void unlockTwo(SideTable *lock1, SideTable *lock2);&#125;; RefcountMap :引用计数表 weak_table_t: 123456struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;&#125;; 先来看\b一下源码的注释，理解一下做法。12345678// Update a weak variable.// If HaveOld is true, the variable has an existing value // that needs to be cleaned up. This value might be nil.// If HaveNew is true, there is a new value that needs to be // assigned into the variable. This value might be nil.// If CrashIfDeallocating is true, the process is halted if newObj is // deallocating or newObj&apos;s class does not support weak references. // If CrashIfDeallocating is false, nil is stored instead. 这个接口是用来更新weak变量的 如果HaveOld是ture，weak变量已经指向了某个对象，就先清除这个对象，然后指向新的对象，这个对象可能是nil 如果HaveNew是ture 有新的对象来替换，那么要将这个对象存起来。这个新的对象可能是nil 如果crashifdeallocation是ture，那么如果指向的对象已经被释放或者该对象不支持weak引用，这个进程会停止 \b如果crashifdeallocation是false，nil会被储存起来 然后祭出源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110idobjc_storeWeak(id *location, id newObj)&#123; return storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object *)newObj);&#125;enum CrashIfDeallocating &#123; DontCrashIfDeallocating = false, DoCrashIfDeallocating = true&#125;;template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id //传入的 location 指向旧的\b引用对象 newobj是新的引用对象storeWeak(id *location, objc_object *newObj)&#123; assert(haveOld || haveNew); if (!haveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; SideTable *newTable; // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: if (haveOld) &#123; oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (haveNew) &#123; newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; // 接下来会有读写操作，加锁，防止数据竞争 SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); //如果有旧值，但是location与oldObj不同，说明location已经被处理过了 if (haveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; &#125; // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. if (haveNew &amp;&amp; newObj) &#123; //新引用的isa指正 Class cls = newObj-&gt;getIsa(); //if cls非空&amp;&amp;未初始化 if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; //解锁 SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); // 初始化 _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. //更新初始化过的cls previouslyInitializedClass = cls; goto retry; &#125; &#125; // Clean up old value, if any. 清除旧值 if (haveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // Assign new value, if any. 分配新值 if (haveNew) &#123; newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table.设置标记位 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; newObj-&gt;setWeaklyReferenced_nolock(); &#125; // Do not set *location anywhere else. That would introduce a race. 只能在这里修改location *location = (id)newObj; &#125; else &#123; // No new value. The storage is not changed. &#125; //处理完成 解锁 SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);//\b返回newObj return (id)newObj;&#125; 检查是否有新值或旧值（haveOld==false&amp;&amp;haveNew==false的情况可能发生吗？）1assert(haveOld || haveNew); 如果没有新值，判断传入的newObj1if (!haveNew) assert(newObj == nil); 创建两张表12SideTable *oldTable;SideTable *newTable; : 一个全局的Hash Map，用来管理所有对象的引用计数和weak指针。1234567891011121314* 如果有旧值，以oldObj为索引 从SideTables取出\b相应的结构体* 如果有新值，以newOb为索引 取出相应的结构体```objcif (haveOld) &#123; oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125;if (haveNew) &#123; newTable = &amp;SideTables()[newObj];&#125; else &#123; newTable = nil;&#125; 判断cls是否为空以及是否初始化12345678910111213141516171819if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; //解锁 SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); // 初始化 _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. //更新初始化过的cls previouslyInitializedClass = cls; goto retry;&#125; 清除旧值123if (haveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);&#125; 分配新值 123456789101112131415161718// Assign new value, if any. if (haveNew) &#123; newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table.设置标记位 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; newObj-&gt;setWeaklyReferenced_nolock(); &#125; // Do not set *location anywhere else. That would introduce a race. 只能在这里修改location *location = (id)newObj;&#125;else &#123; // No new value. The storage is not changed.&#125; 处理完成后1234//解锁 SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);//\b返回newObj return (id)newObj; 相关细节：weak_unregister_no_lock 移除旧的\b指针\b:\bobjc-weak.mm line 348123456789101112131415161718192021222324252627282930313233343536373839//weak_table referent_id要\b指向的对象 *referrer_id指针voidweak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id)&#123; //旧的指针 objc_object *referent = (objc_object *)referent_id; //指向。。的指针 objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; //判断 if (!referent) return;// 判断weak_table是否存在对\b该对象的weak_entry//weak_entry_for_referent ：返回对象的weak_entry if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; //移除该entry\b中的指针 remove_referrer(entry, referrer); bool empty = true; if (entry-&gt;out_of_line() &amp;&amp; entry-&gt;num_refs != 0) &#123; empty = false; &#125; else &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i]) &#123; empty = false; break; &#125; &#125; &#125;//如果该entry为空 则删除之 if (empty) &#123; weak_entry_remove(weak_table, entry); &#125; &#125; // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.&#125; The global weak references table. Stores object ids as keys, and weak_entry_t structs as their values. 123456struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;&#125;; weak_register_no_lock \b新的指针:\bobjc-weak.mm line 39112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; if (!referent || referent-&gt;isTaggedPointer()) return referent_id; //判断被引用的对象\b存活 // ensure that the referenced object is viable bool deallocating; // 是否支持内存管理 if (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123; //定义为是否正在销毁 deallocating = referent-&gt;rootIsDeallocating(); &#125; else &#123; //\b\b允许弱引用 BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) &#123; return nil; &#125; deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); &#125; if (deallocating) &#123; //crashIfDeallocating为true时（篇首有提到）,结束进程 if (crashIfDeallocating) &#123; _objc_fatal(\"Cannot form weak reference to instance (%p) of \" \"class %s. It is possible that this object was \" \"over-released, or is in the process of deallocation.\", (void*)referent, object_getClassName((id)referent)); &#125; else &#123; return nil; &#125; &#125; // now remember it and where it is being stored weak_entry_t *entry; // 判断weak_table是否存在对\b该对象的weak_entry if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; //该entry中新增指针 append_referrer(entry, referrer); &#125; else &#123; // 新增该对象的weak_entry weak_entry_t new_entry(referent, referrer); weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); &#125; // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;&#125; \b对象释放,引用计数为0时 的调用顺序如下： objc_release dealloc _objc_rootDealloc object_dispose objc_destructInstance objc_clear_deallocating clearDeallocating clearDeallocating_slow weak_clear_no_lock 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//referent_id 要释放的对象void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id;// 取出该对象的weak_entry weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn't happen, but does with mismatched CF/objc //printf(\"XXX no entry for clear deallocating %p\\n\", referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; //\b判断采用的是定长数组还是动态数组 if (entry-&gt;out_of_line()) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; //\b遍历weak_entry 置为nil for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform(\"__weak variable at %p holds %p instead of %p. \" \"This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125; 看到这里就破案啦， SideTables是一个全局的Hash表，里面存放了对象的\bweak指针和引用计数。里面装的是SideTable。对象的内存地址为key ，weak指针和引用计数为value 当\b有weak指针指向、更改指向对象时，会根据对象的内存地址取出相应的SideTable\b增加、删除相应的weak指针 当对象回收时，会调用weak_clear_no_lock,在全局的weak_table中取出\b该对象相应的\bweak_entry,然后将里面的weak指针记为nil（所以weak不会引起野指针的问题，因为指向对象的内存块回收时，指针也被置为nil了）","categories":[],"tags":[]},{"title":"iOS事件响应链","slug":"iOS事件响应链","date":"2018-11-25T16:51:41.000Z","updated":"2019-05-01T10:14:27.302Z","comments":true,"path":"2018/11/26/iOS事件响应链/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/iOS事件响应链/","excerpt":"","text":"触摸事件的响应机制： 系统检测到触摸等事件后，会将事件打包成UIEvent对象发给当前活动的APP的事件队列。 UIApplication会从事件队列中取出事件并传递给UIWindow UIWindow会使用hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图(View) hitTest:withEvent:会在当前视图上调用pointInside:withEvent:方法判断触摸点是否在\b当前视图内。若返回NO则hitTest:withEvent:返回nil，若返回YES则向当前视图的所有subviews发送hitTest:withEvent:直到有子视图返回非空对象或者全部子视图遍历完毕。 针对以上内容，我写了一个demo：处理的case有两个： 直接让父视图响应 子视图超出父视图的部分也能响应 \b\b","categories":[],"tags":[]},{"title":"关于catogory的几个问题","slug":"catogory的几个问题","date":"2018-11-25T16:51:02.000Z","updated":"2019-05-01T10:14:27.302Z","comments":true,"path":"2018/11/26/catogory的几个问题/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/catogory的几个问题/","excerpt":"","text":"先介绍分类：分类可以为已经存在的类添加方法，还可以把类的实现分在几个不同的文件里。Q1：下面这段话摘自美团点评的文章： category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）我们可以在objc的源码中看到category的结构，如下：12345678typedef struct category_t &#123; const char *name;// 类名 classref_t cls;// 要扩展的类对象 struct method_list_t *instanceMethods;// 实例方法 struct method_list_t *classMethods;// 类方法 struct protocol_list_t *protocols;// 分类实现的协议 struct property_list_t *instanceProperties;// 分类的属性&#125; category_t; 从结构中可以知道，分类可以添加实例方法、类方法、协议、属性，但是无法添加实例变量。 Q2：为什么分类方法会覆盖原来的类方法 先问是不是，再问为什么首先答案是NO 验证方法很简单，打印出方法列表，会发现原来的类方法还在，所谓的覆盖指的是“分类中的方法在方法查找时会先于原来的类方法被命中”###为什么呢？运行时 遍历各个分类中的方法【listA】与原来类的方法【listB】然后组成一个大的方法列表newlist，A在前，B在后，如果listA与listB中都有一个methodA，那么在方法查找时，排在newlist前的分类方法会先被找到，就会让调用者产生“原来的类方法被分类方法覆盖之感”以此可推，如果在实际应用中我们想要调用“被覆盖的方法”，可以获取类的方法列表，从后往前遍历，找到要调用的方法即可【或者从前往后遍历，获取同名的方法列表，然后取出最后一个】 Q3：","categories":[],"tags":[]},{"title":"app启动过程","slug":"app启动过程","date":"2018-11-25T16:50:28.000Z","updated":"2019-05-01T10:14:27.301Z","comments":true,"path":"2018/11/26/app启动过程/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/app启动过程/","excerpt":"","text":"最开始的时候呢，是看了sunny的博客：http://blog.sunnyxx.com/2014/08/30/objc-pre-main/和mike ash的博客：https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html但是没看过源码一头雾水的，所以花了周末的时间，看了源码。下面的是我的一些总结，也算是题纲。然后我的草稿也继续保留。刚开始写博客，希望思路会越来越好。引自sunny的博客 dyld（the dynamic link editor），Apple 的动态链接器，系统 kernel 做好启动程序的初始准备后，交给 dyld 负责，援引并翻译《 Mike Ash 这篇 blog 》对 dyld 作用顺序的概括： 从 kernel 留下的原始调用栈引导和启动自己 将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制 non-lazy 符号立即 link 到可执行文件，lazy 的存表里 Runs static initializers for the executable 找到可执行文件的 main 函数，准备参数并调用 程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口 程序main函数 return 后执行 static terminator 某些场景下 main 函数结束后调 libSystem 的 _exit 函数 Mach-O文件Mach-O文件格式是OSX和iOS系统上的可执行文件格式，【.O文件、动态库都是\b这个格式】结构如下:mach_header app 编译打包的过程这个地方贴一下计算机原理的示意图 app 启动的过程dyldiOS中系统级别的framework都是动态链接的。原因有三，一是为了减少体积，编译的时候不需要打包进去。二是代码可以共用，因为系统下的APP用到的同一个framework都是一样的。 三是便于更新。静态链接的的framework比如我们常用到的第三方库SVProgressHUD是在编译时链接好的。iOS不允许我们用到系统以外的动态链接库。原因，emmm,everybody knows\b\b源码里的汇编太难啃 ，揪出 __dyld_start ,调用栈如下 __dyld_start dyldbootstrap::start _main __dyld_start 12345678910111213141516171819202122232425262728__dyld_start: mov x28, sp and sp, x28, #~15 // force 16-byte alignment of stack mov x0, #0 mov x1, #0 stp x1, x0, [sp, #-16]! // make aligned terminating frame mov fp, sp // set up fp to point to terminating frame sub sp, sp, #16 // make room for local variables ldr x0, [x28] // get app&apos;s mh into x0 ldr x1, [x28, #8] // get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment) add x2, x28, #16 // get argv into x2 adrp x4,___dso_handle@page add x4,x4,___dso_handle@pageoff // get dyld&apos;s mh in to x4 adrp x3,__dso_static@page ldr x3,[x3,__dso_static@pageoff] // get unslid start of dyld sub x3,x4,x3 // x3 now has slide of dyld mov x5,sp // x5 has &amp;startGlue // call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue) bl __ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm mov x16,x0 // save entry point address in x16 ldr x1, [sp] cmp x1, #0 b.ne Lnew // LC_UNIXTHREAD way, clean up stack and jump to result add sp, x28, #8 // restore unaligned stack pointer without app mh br x16 // jump to the program&apos;s entry point dyldbootstrap::start做的主要事情是初始化参数，并调用main，返回mian函数的地址main函数：1234567......return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);......uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue) 参数：mainExecutableMH:当前app的Mach-O头部信息。 macho_header结构体的\b结构可以在源码中查看【源码中： The 64-bit mach header appears at the very beginning of object files for 64-bit architectures. The 32-bit mach header appears at the very beginning of the object file for 32-bit architectures.】 mainExecutableSlide:地址的偏移量argc:argv[]:envp[]:apple[]:startGlue: 后面的都是草稿，，别看了。。 main()调用之前的加载过程 先将可执行文件加载， \b加载dyld dyld dyld加载dylib（） 调用栈 __dyld_start dyldbootstrap::start _main 先看start()mainExecutableMH(macho_header) 头部信息和 mainExecutableSlide(uintptr_t)偏移量1234567891011121314151617181920212223242526272829303132333435uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue)&#123; // if kernel had to slide dyld, we need to fix up load sensitive locations // we have to do this before using any global variables //如果不是在规定的地址处载入dyld 则需要重新定位dyld if ( slide != 0 ) &#123; rebaseDyld(dyldsMachHeader, slide); &#125; // allow dyld to use mach messaging //初始化 mach_init(); // kernel sets up env pointer to be just past end of agv array const char** envp = &amp;argv[argc+1]; // kernel sets up apple pointer to be just past end of envp array const char** apple = envp; while(*apple != NULL) &#123; ++apple; &#125; ++apple; // set up random value for stack canary __guard_setup(apple);#if DYLD_INITIALIZER_SUPPORT // run all C++ initializers inside dyld runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);#endif // now that we are done bootstrapping dyld, call dyld's main uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader); return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);&#125; 接下来是_main这个函数有点长，要耐心看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; uintptr_t result = 0; //头部信息 sMainExecutableMachHeader = mainExecutableMH;#if __MAC_OS_X_VERSION_MIN_REQUIRED // if this is host dyld, check to see if iOS simulator is being run //准备工作 const char* rootPath = _simple_getenv(envp, &quot;DYLD_ROOT_PATH&quot;); if ( rootPath != NULL ) &#123; // look to see if simulator has its own dyld char simDyldPath[PATH_MAX]; strlcpy(simDyldPath, rootPath, PATH_MAX); strlcat(simDyldPath, &quot;/usr/lib/dyld_sim&quot;, PATH_MAX); int fd = my_open(simDyldPath, O_RDONLY, 0); if ( fd != -1 ) &#123; result = useSimulatorDyld(fd, mainExecutableMH, simDyldPath, argc, argv, envp, apple, startGlue); if ( !result &amp;&amp; (*startGlue == 0) ) halt(&quot;problem loading iOS simulator dyld&quot;); return result; &#125; &#125;#endif CRSetCrashLogMessage(&quot;dyld: launch started&quot;);#if LOG_BINDINGS char bindingsLogPath[256]; const char* shortProgName = &quot;unknown&quot;; if ( argc &gt; 0 ) &#123; shortProgName = strrchr(argv[0], &apos;/&apos;); if ( shortProgName == NULL ) shortProgName = argv[0]; else ++shortProgName; &#125; //\b拼接路径 mysprintf(bindingsLogPath, &quot;/tmp/bindings/%d-%s&quot;, getpid(), shortProgName); // 读取 sBindingsLogfile = open(bindingsLogPath, O_WRONLY | O_CREAT, 0666); if ( sBindingsLogfile == -1 ) &#123; ::mkdir(&quot;/tmp/bindings&quot;, 0777); sBindingsLogfile = open(bindingsLogPath, O_WRONLY | O_CREAT, 0666); &#125; //dyld::log(&quot;open(%s) =&gt; %d, errno = %d\\n&quot;, bindingsLogPath, sBindingsLogfile, errno);#endif //设置上下文 setContext(mainExecutableMH, argc, argv, envp, apple); // Pickup the pointer to the exec path. //指针指向执行路径 sExecPath = _simple_getenv(apple, &quot;executable_path&quot;); // &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld if (!sExecPath) sExecPath = apple[0]; bool ignoreEnvironmentVariables = false; if ( sExecPath[0] != &apos;/&apos; ) &#123; // have relative path, use cwd to make absolute char cwdbuff[MAXPATHLEN]; if ( getcwd(cwdbuff, MAXPATHLEN) != NULL ) &#123; // maybe use static buffer to avoid calling malloc so early... char* s = new char[strlen(cwdbuff) + strlen(sExecPath) + 2]; strcpy(s, cwdbuff); strcat(s, &quot;/&quot;); strcat(s, sExecPath); sExecPath = s; &#125; &#125; // Remember short name of process for later logging //为之后的日志输出记录 sExecShortName = ::strrchr(sExecPath, &apos;/&apos;); if ( sExecShortName != NULL ) ++sExecShortName; else sExecShortName = sExecPath; sProcessIsRestricted = processRestricted(mainExecutableMH, &amp;ignoreEnvironmentVariables, &amp;sProcessRequiresLibraryValidation); if ( sProcessIsRestricted ) &#123;#if SUPPORT_LC_DYLD_ENVIRONMENT checkLoadCommandEnvironmentVariables();#endif pruneEnvironmentVariables(envp, &amp;apple); // set again because envp and apple may have changed or moved setContext(mainExecutableMH, argc, argv, envp, apple); &#125; else &#123; if ( !ignoreEnvironmentVariables ) checkEnvironmentVariables(envp); defaultUninitializedFallbackPaths(envp); &#125; if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv); if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); getHostInfo(mainExecutableMH, mainExecutableSlide); // install gdb notifier stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB); stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages); // make initial allocations large enough that it is unlikely to need to be re-alloced sAllImages.reserve(INITIAL_IMAGE_COUNT); sImageRoots.reserve(16); sAddImageCallbacks.reserve(4); sRemoveImageCallbacks.reserve(4); sImageFilesNeedingTermination.reserve(16); sImageFilesNeedingDOFUnregistration.reserve(8); #ifdef WAIT_FOR_SYSTEM_ORDER_HANDSHAKE // &lt;rdar://problem/6849505&gt; Add gating mechanism to dyld support system order file generation process WAIT_FOR_SYSTEM_ORDER_HANDSHAKE(dyld::gProcessInfo-&gt;systemOrderFlag);#endif try &#123; // add dyld itself to UUID list // 将dyldimage加入uuidlist addDyldImageToUUIDList(); CRSetCrashLogMessage(sLoadingCrashMessage); // instantiate ImageLoader for main executable //初始化instantiateFromLoadedImage sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath); // \b配置上下文信息 gLinkContext.mainExecutable = sMainExecutable; gLinkContext.processIsRestricted = sProcessIsRestricted; gLinkContext.processRequiresLibraryValidation = sProcessRequiresLibraryValidation; gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);#if TARGET_IPHONE_SIMULATOR #if TARGET_OS_WATCH || TARGET_OS_TV // disable error during bring up of these simulators #else // check main executable is not too new for this OS &#123; if ( ! isSimulatorBinary((uint8_t*)mainExecutableMH, sExecPath) ) &#123; throwf(&quot;program was built for Mac OS X and cannot be run in simulator&quot;); &#125; uint32_t mainMinOS = sMainExecutable-&gt;minOSVersion(); // dyld is always built for the current OS, so we can get the current OS version // from the load command in dyld itself. uint32_t dyldMinOS = ImageLoaderMachO::minOSVersion((const mach_header*)&amp;__dso_handle); if ( mainMinOS &gt; dyldMinOS ) &#123; throwf(&quot;app was built for iOS %d.%d which is newer than this simulator %d.%d&quot;, mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); &#125; &#125; #endif#endif // load shared cache checkSharedRegionDisable(); #if DYLD_SHARED_CACHE_SUPPORT if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) mapSharedCache(); #endif // Now that shared cache is loaded, setup an versioned dylib overrides #if SUPPORT_VERSIONED_PATHS checkVersionedPaths(); #endif // load any inserted libraries if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123; for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); &#125; // record count of inserted libraries so that a flat search will look at // inserted libraries, then main, then others. sInsertedDylibCount = sAllImages.size()-1; // link main executable gLinkContext.linkingMainExecutable = true; link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL)); sMainExecutable-&gt;setNeverUnloadRecursive(); if ( sMainExecutable-&gt;forceFlat() ) &#123; gLinkContext.bindFlat = true; gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding; &#125; // link any inserted libraries // do this after linking main executable so that any dylibs pulled in by inserted // dylibs (e.g. libSystem) will not be in front of dylibs the program uses if ( sInsertedDylibCount &gt; 0 ) &#123; //链接 细节见下方 for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL)); image-&gt;setNeverUnloadRecursive(); &#125; // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works // interposing info 这个是什么意思 for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; image-&gt;registerInterposing(); &#125; &#125; // &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES for (int i=sInsertedDylibCount+1; i &lt; sAllImages.size(); ++i) &#123; ImageLoader* image = sAllImages[i]; if ( image-&gt;inSharedCache() ) continue; image-&gt;registerInterposing(); &#125; // apply interposing to initial set of images for(int i=0; i &lt; sImageRoots.size(); ++i) &#123; sImageRoots[i]-&gt;applyInterposing(gLinkContext); &#125; gLinkContext.linkingMainExecutable = false; // &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked sMainExecutable-&gt;weakBind(gLinkContext); CRSetCrashLogMessage(&quot;dyld: launch, running initializers&quot;); //调用所有的image的initializer方法 #if SUPPORT_OLD_CRT_INITIALIZATION // Old way is to run initializers via a callback from crt1.o if ( ! gRunInitializersOldWay ) initializeMainExecutable(); #else // run all initializers initializeMainExecutable(); #endif // find entry point for main executable result = (uintptr_t)sMainExecutable-&gt;getThreadPC(); if ( result != 0 ) &#123; // main executable uses LC_MAIN, needs to return to glue in libdyld.dylib if ( (gLibSystemHelpers != NULL) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= 9) ) *startGlue = (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit; else halt(&quot;libdyld.dylib support not present for LC_MAIN&quot;); &#125; else &#123; // main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main() result = (uintptr_t)sMainExecutable-&gt;getMain(); *startGlue = 0; &#125; &#125; catch(const char* message) &#123; syncAllImages(); halt(message); &#125; catch(...) &#123; dyld::log(&quot;dyld: launch failed\\n&quot;); &#125; CRSetCrashLogMessage(NULL); return result;&#125; addDyldImageToUUIDList细节 123456789101112131415161718192021static void addDyldImageToUUIDList()&#123; const struct macho_header* mh = (macho_header*)&amp;__dso_handle; const uint32_t cmd_count = mh-&gt;ncmds; const struct load_command* const cmds = (struct load_command*)((char*)mh + sizeof(macho_header)); const struct load_command* cmd = cmds; for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123; switch (cmd-&gt;cmd) &#123; case LC_UUID: &#123; uuid_command* uc = (uuid_command*)cmd; dyld_uuid_info info; info.imageLoadAddress = (mach_header*)mh; memcpy(info.imageUUID, uc-&gt;uuid, 16); addNonSharedCacheImageUUID(info); return; &#125; &#125; cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize); &#125;&#125; ImageLoader::link细节 也就是题纲说的link的细节12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths)&#123; //dyld::log(\"ImageLoader::link(%s) refCount=%d, neverUnload=%d\\n\", this-&gt;getPath(), fDlopenReferenceCount, fNeverUnload); // clear error strings (*context.setErrorStrings)(dyld_error_kind_none, NULL, NULL, NULL); uint64_t t0 = mach_absolute_time(); //\b递归加载所有的library this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths); context.notifyBatch(dyld_image_state_dependents_mapped); // we only do the loading step for preflights if ( preflightOnly ) return; uint64_t t1 = mach_absolute_time(); context.clearAllDepths(); this-&gt;recursiveUpdateDepth(context.imageCount()); uint64_t t2 = mach_absolute_time(); //递归修复\b地址 this-&gt;recursiveRebase(context); context.notifyBatch(dyld_image_state_rebased); //递归绑定 uint64_t t3 = mach_absolute_time(); this-&gt;recursiveBind(context, forceLazysBound, neverUnload); uint64_t t4 = mach_absolute_time(); if ( !context.linkingMainExecutable ) this-&gt;weakBind(context); uint64_t t5 = mach_absolute_time(); context.notifyBatch(dyld_image_state_bound); uint64_t t6 = mach_absolute_time(); std::vector&lt;DOFInfo&gt; dofs; this-&gt;recursiveGetDOFSections(context, dofs); context.registerDOFs(dofs); uint64_t t7 = mach_absolute_time(); // interpose any dynamically loaded images if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != 0) ) &#123; this-&gt;recursiveApplyInterposing(context); &#125; // clear error strings (*context.setErrorStrings)(dyld_error_kind_none, NULL, NULL, NULL); fgTotalLoadLibrariesTime += t1 - t0; fgTotalRebaseTime += t3 - t2; fgTotalBindTime += t4 - t3; fgTotalWeakBindTime += t5 - t4; fgTotalDOF += t7 - t6; // done with initial dylib loads fgNextPIEDylibAddress = 0;&#125; 动态链接库包括：iOS 中用到的所有系统 framework加载OC runtime方法的libobjc，系统级别的libSystem，例如libdispatch(GCD)和libsystem_blocks (Block) 动态链接库加载的具体流程动态链接库的加载步骤具体分为5步：1.load dylibs image 读取库镜像文件2.Rebase image3.Bind image4.Objc setup5.initializers","categories":[],"tags":[]},{"title":"做用户轨迹追踪时的思考","slug":"做用户轨迹追踪时的思考","date":"2018-11-25T16:50:06.000Z","updated":"2019-05-01T10:14:27.303Z","comments":true,"path":"2018/11/26/做用户轨迹追踪时的思考/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/做用户轨迹追踪时的思考/","excerpt":"","text":"确切地说是目前采用的方案。 why 快速定位用户反馈的问题 运营可自定义追踪行为，方便研究 为产品定位做更多的参考 what 追踪代码和业务代码分离 抽离出来作为其他项目的Kit使用 根据后台动态下发的文件追踪相应的页面、事件,并根据设置确定日志上传时机 how1. 追踪页面轨迹 主要借助nav的api 记下push\\popset\\present\\dismiss的日志 对于每个一vc用地址、className来标记，前者用来标记vc数组，后者用来匹配路径 对于有tab的app，记录下当前的tab页很重要。我采用的方法是，hook住funname、funname记录下tabName或者tabIndex，后者只有在代码主动设置selectedIndex的才会调用，前者会在用户点击tabItem的时候响应。对于后者，我们可以取index做标记；对于前者，我们可以取itemName做标记，因此如果对追踪路径有要求，有两个方式。 app端，对tabName和index做一个对照 后端配置时直接采用tabName||index的方式 2. 追踪点击事件 响应链 点击事件分: UIControl类点击事件继承自UIControl的响应组件在响应到事件后，会将target、action转发给单例UIApplication,由UIApplication完成分发。 调用栈如下 RunLoopRun… UIApplication sendEvent UIWindow sendEvent UIWindow sendTouchesForEvent UIControl… UIApplication sendAction:to:from:forEvent:*objc_sendMsg 因此，我们可以hook住UIApplication的sendAction:(SEL)action to:(nullable id)target from:(nullable id)sender forEvent:(nullable UIEvent *)event方法，记录点击空间、响应对象、以及消息，而不必对UIButton、UISwitch等组件分别hook。 对于实际项目，我们需要用户具体点击了哪个button、switch 在这里，我没有采用tag之类的标志，首先加tag需要改动太多的业务代码，而且加了tag之后，还另外需要一张对照表来记录关系。 系统自带的api可以满足我们的需求。 以UIButton为例，UI上，我们会给其设置图片或者标题，直接用这个来标记，日志的可读性更佳。 读取UIButton的标题不比赘述。 这里这里介绍一下如何用图片来标记UIButton。 UI控件有一个属性accessibilityIdentifier,习惯用storyboard的话，应该很熟悉这个属性。 我们可以利用这个属性，在hook出设置图片的api，直接用图片的名字来作为标记。 这样，我们对于一个button，可以用标题或者图片名来标记了，非常友好 UIGestureRecognizer 类响应的手势 对于这类事件，大多数人的做法是hook住该类的init方法，然后再写一个target的分类，hook相应的方法。此法可行，但是要给业务类写分类，我并不十分想这么干。。。。于是我机智地查看了调用栈， RunLoopRun… UIApplication sendEvent UIWindow sendEvent UIGestureEnvironment _deliverEvent: toGestureRecognizers:usingBlock: UIGestureRecognizer _updateGesture… UIGestureRecognizerTarget _sendActionWithGestureRecognizer:*objc_sendMsg 很明显，~~~~ 但是悲剧地发现 UIGestureRecognizerTarget是一个私有类 难道这就是结束了吗？并不是。 其实我们的诉求还是需要知道sender、target、 至于是在哪个VC内的控件，我们可以通过路径轨迹得知，不必纠结于此。 tableView 等点击事件要hooktableView的delegate、以及delegate相应的sel方法。也就是要给业务类写分类了。。我并不十分想这么干。。。。然而除此以外，我没有想出特别好的办法。卒。 3. 日志日志记录格式：时间– 路径名- 响应视图（视图标志） 响应视图（视图标志） 响应视图（视图标志） …..时间– 路径名- 响应视图（视图标志） 响应视图（视图标志） 响应视图（视图标志） …..实时写入本地的txt文件中上传策略由配置文件来决定 4. test5. improve tableView等cell上的点击事件我还要继续找寻更好的方法 ps.虽然现在用户真的很少，有些东西可研究可不研究，可做可不做，但是想到了不去做，就是觉得todo list越来越长很想去完成啊源码可以在我的github上，Pie这个项目里找到【\b不一定更新了】","categories":[],"tags":[]},{"title":"自动释放池的原理","slug":"自动释放池的原理","date":"2018-11-25T16:49:34.000Z","updated":"2019-05-01T10:14:27.304Z","comments":true,"path":"2018/11/26/自动释放池的原理/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/自动释放池的原理/","excerpt":"","text":"背景:前文提到了weak修饰对象原理。对于iOS如何管理内存的释放销毁，还需要知道自动释放池技术，故本文会在源码的基础上讨论。 autoreleasepool先总结： ARC下，非alloc/new/copy/mutableCopy开头的类方法默认返回的是autoreleased对象，编译器会自动插入相关的autorelease语句 主线程的runloop进入时（entry），其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。 准备进入休眠(BeforeWaiting) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；即将退出Loop(Exit) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。 官方文档：https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-1041876https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/doc/uid/TP40003623 构造函数、析构函数 12345struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; 自动释放池的实现原理12345678910111213/*********************************************************************** Autorelease pool implementation A thread&apos;s autorelease pool is a stack of pointers. Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary. A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released. The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary. Thread-local storage points to the hot page, where newly autoreleased objects are stored. **********************************************************************/ 线程的自动释放池是一个指针栈 每个指针代表了要释放的对象或者是POOL_BOUNDARY（自动释放池的边界对象） 自动释放池pop时，在POOL_BOUNDARY之后push进来的对象会被释放 这个栈由若干双向列表构成。每页会在在必要的情况下增、删 TLS\b(Thread-local storage)指向最近储存的page(\bhotpage) TLS： Thread-local storage (TLS) is a computer programming method that uses static or global memory local to a thread. AutoreleasePool是以AutoreleasePoolPage为单位构造的双向链表 对象发出autorelease消息后 会加入AutoreleasePoolPage中。调用autorelease::pop时,会向AutoreleasePoolPage中的对象发送release消息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class AutoreleasePoolPage &#123; // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is // pushed and it has never contained any objects. This saves memory // when the top level (i.e. libdispatch) pushes and pops pools but // never uses them.# define EMPTY_POOL_PLACEHOLDER ((id*)1)# define POOL_BOUNDARY nil //分界线 static pthread_key_t const key = AUTORELEASE_POOL_KEY; static uint8_t const SCRIBBLE = 0xA3; // 0xA3A3A3A3 after releasing static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size #else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id); magic_t const magic;// magic_t id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat; .... id * begin() &#123; return (id *) ((uint8_t *)this+sizeof(*this)); &#125; id * end() &#123; return (id *) ((uint8_t *)this+SIZE); &#125; ........ id *add(id obj) &#123; assert(!full()); unprotect(); id *ret = next; // faster than `return next-1` because of aliasing *next++ = obj; protect(); return ret; &#125; ....... void releaseAll() &#123; releaseUntil(begin()); &#125;&#125;\b\b 消息调用栈 对象发出autorelease rootAutorelease rootAutorelease2 AutoreleasePoolPage::autorelease autoreleaseFast1234567891011static inline id *autoreleaseFast(id obj) &#123; AutoreleasePoolPage *page = hotPage();//取出hotPage if (page &amp;&amp; !page-&gt;full()) &#123;//page存在且没满 return page-&gt;add(obj);//对象加入该\bpage &#125; else if (page) &#123;//该页已满 return autoreleaseFullPage(obj, page);//调用autoreleaseFullPage 替换当前的hotPAge 然后再\b执行add（obj） &#125; else &#123;//当前没有page return autoreleaseNoPage(obj);//调用autoreleaseNoPage \b新增page 然后再\b执行add（obj） &#125; &#125; 实现细节hotPage()12345678static inline AutoreleasePoolPage *hotPage() &#123; AutoreleasePoolPage *result = (AutoreleasePoolPage *) tls_get_direct(key);//根据tls取出最近储存的page if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil; if (result) result-&gt;fastcheck(); return result;&#125; add(obj)12345678910id *add(id obj)&#123; assert(!full()); unprotect();// id *ret = next; // faster than `return next-1` because of aliasing *next++ = obj;//并没有判断obj==nil protect(); return ret;&#125; autoreleaseFullPage12345678910111213141516171819id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)&#123; // The hot page is full. // Step to the next non-full page, adding a new page if necessary. // Then add the object to that page. //该页已满，向链表的child方向遍历，直到找到不满的page为止，如果遍历完还是没有符合要求的page，则new一个，并标记为hotPage， //在hotpage中加入obj assert(page == hotPage()); assert(page-&gt;full() || DebugPoolAllocation); do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125; autoreleaseNoPage12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849id *autoreleaseNoPage(id obj)&#123; // \"No page\" could mean no pool has been pushed // or an empty placeholder pool has been pushed and has no contents yet assert(!hotPage()); bool pushExtraBoundary = false; if (haveEmptyPoolPlaceholder()) &#123; // We are pushing a second pool over the empty placeholder pool // or pushing the first object into the empty placeholder pool. // Before doing that, push a pool boundary on behalf of the pool // that is currently represented by the empty placeholder. pushExtraBoundary = true; &#125; else if (obj != POOL_BOUNDARY &amp;&amp; DebugMissingPools) &#123; // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(\"MISSING POOLS: (%p) Object %p of class %s \" \"autoreleased with no pool in place - \" \"just leaking - break on \" \"objc_autoreleaseNoPool() to debug\", pthread_self(), (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; &#125; else if (obj == POOL_BOUNDARY &amp;&amp; !DebugPoolAllocation) &#123; // We are pushing a pool with no pool in place, // and alloc-per-pool debugging was not requested. // Install and return the empty pool placeholder. return setEmptyPoolPlaceholder(); &#125; // We are pushing an object or a non-placeholder'd pool. // Install the first page. //new一个并标记为hotpage AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); // Push a boundary on behalf of the previously-placeholder'd pool. //当 pushExtraBoundary 加入一个nil对象 作为边界标记 if (pushExtraBoundary) &#123; page-&gt;add(POOL_BOUNDARY); &#125; // Push the requested object or pool. //obj加入 return page-&gt;add(obj);&#125; objc_autoreleasePoolPop AutoreleasePoolPage::pop releaseUntil releaseUntil:123456789101112131415161718192021222324252627282930313233343536 void releaseUntil(id *stop) &#123; // Not recursive: we don't want to blow out the stack // if a thread accumulates a stupendous amount of garbage while (this-&gt;next != stop) &#123; // Restart from hotPage() every time, in case -release // autoreleased more objects AutoreleasePoolPage *page = hotPage(); // fixme I think this `while` can be `if`, but I can't prove it while (page-&gt;empty()) &#123; page = page-&gt;parent; setHotPage(page); &#125; page-&gt;unprotect(); //从next开始往前取 id obj = *--page-&gt;next; memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); page-&gt;protect(); //直到POOL_BOUNDARY为止，向obj发送release消息 if (obj != POOL_BOUNDARY) &#123; objc_release(obj); &#125; &#125; //重新标记hotPage setHotPage(this);#if DEBUG // we expect any children to be completely empty for (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123; assert(page-&gt;empty()); &#125;#endif &#125; #总结1： 当对象发送autorelease消息时，有三种情况 hotPage&amp;&amp;!full page-&gt;add(obj) hotPage&amp;&amp;full autoreleaseFullPage page-&gt;add(obj) !hotPage autoreleaseNoPage page-&gt;add(obj)总结二 当调用AutoreleasePoolPage::pop时，会向栈内的对象发送release消息其他问题 刚刚提到我们会在new一个page的时候压入一个nil（POOL_BOUNDARY）作为边界标记","categories":[],"tags":[]},{"title":"消息转发","slug":"消息转发","date":"2018-11-25T16:48:54.000Z","updated":"2019-05-01T10:14:27.303Z","comments":true,"path":"2018/11/26/消息转发/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/消息转发/","excerpt":"","text":"backgroundwhywhat ps 总是会看到各种博文里提到runtime我觉得runtime 有两个角度可以解释 一套用c实现的底层API 源码可以在apple的source library里下载 一种动态运行机制 在iOS中，程序运行时调用的方法【or 消息】并不是编译时期就确定下来的，可以在运行时才确定、甚至是修改。消息转发的机制，也是因为有runtime，才能如此设计。 疑问：forwardingTarget和forwardInvocation在本来找不到对应的方法时，可以将消息转发给可以其他对象，那他们的区别是什么？ how在源码里找了一下对应的实现forwardInvocation的调用栈： forwardInvocation doesNotRecognizeSelector _objc_fatal写了一个很简单的demo来模拟了一下： 123456789101112@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self sendMsg]; // Do any additional setup after loading the view, typically from a nib.&#125;- (void)sendMsg&#123; [self performSelector:@selector(hello)];&#125;@end ViewController这个类并没有实现hello这个场景很熟悉，如果没有预防\b措施的话，会抛出\b\bunrecognized selector sent to instance XXX 根据消息发送、转发的流程，大概有以下三种方法① 在分类中重写resolveInstanceMethod 动态添加方法12345678910111213+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; NSString *clsStr = NSStringFromSelector(sel); if ([clsStr isEqualToString:@\"hello\"]) &#123; class_addMethod([self class], sel, (IMP)mymethod, \"v@:@\"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void mymethod(id self, SEL _cmd)&#123; NSLog(@\"hello method added\");&#125; ② forwardingTarget 转发12345678- (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSString *clsStr = NSStringFromSelector(aSelector); if ([clsStr isEqualToString:@\"hello\"]) &#123; return [TestObj new]; &#125; return nil;&#125; 在TestObj中实现了：1234- (void)hello&#123; NSLog(@\"found hello\");&#125; ③ forwardInvocation 转发\b1234567891011121314151617- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSString *clsStr = NSStringFromSelector(anInvocation.selector); if ([clsStr isEqualToString:@\"hello\"]) &#123; [anInvocation invokeWithTarget:[TestObj new]]; &#125;&#125;-(NSMethodSignature*)methodSignatureForSelector:(SEL)selector&#123; NSMethodSignature *signature = [super methodSignatureForSelector:selector]; if (! signature) &#123; signature = [[TestObj new] methodSignatureForSelector:selector]; &#125; return signature;&#125; 跟②相似，③也是将消息转发给备用接收者。","categories":[],"tags":[]},{"title":"深入比较strong和copy两种修饰符","slug":"深入比较strong和copy两种修饰符","date":"2018-11-25T16:48:10.000Z","updated":"2019-05-01T10:14:27.304Z","comments":true,"path":"2018/11/26/深入比较strong和copy两种修饰符/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/深入比较strong和copy两种修饰符/","excerpt":"","text":"strong和copy是property的两个基本修饰符，在oc中，一般情况下用来修饰对象。strong：property的默认修饰符。copy：一般用来修饰拥有可变类型的对象。比如NSString NSDictionary NSArray.在学习oc\b的过程中，大多数的资料里都提到了以上两点，却没有详细说明这么做的原因。本文旨在oc底层实现的基础上探讨以上两点的原因和合理性。 一、strong和copy的不同、以及为什么NSString等对象一般用copy来修饰？对象使用strong和copy修饰后，都可以让对象的RC＋1。其不同点可以看一下代码。123456789101112@property (nonatomic,strong) id objStrong;@property (nonatomic,copy) id objCopy;id obj = [[NSMutableDictionary alloc] init];[obj setValue:@\"hello\" forKey:@\"objValue\"];self.objStrong = obj;self.objCopy = [obj copy];NSLog(@\"before obj changed---objStrong:%@ objCopy:%@\",[self.objStrong valueForKey:@\"objValue\"],[self.objCopy valueForKey:@\"objValue\"]);[obj setValue:@\"changed\" forKey:@\"objValue\"];NSLog(@\"after obj changed---objStrong:%@ objCopy:%@\",[self.objStrong valueForKey:@\"objValue\"],[self.objCopy valueForKey:@\"objValue\"]); 可以来查看一下输出12before obj changed---objStrong:hello objCopy:helloafter obj changed---objStrong:changed objCopy:hello 可以看到copy修饰的对象在obj改变前后没有发生变化，而strong修饰的对象则相反。可以肯定的是，\bobjStrong和objCopy指向的不是同一个对象。打印\b对象地址来验证一下：1NSLog(@\"\\rcompare address \\robj:%p \\robjStrong:%p \\robjCopy:%p\",obj,self.objStrong,self.objCopy); 查看输出：1234compare address obj:0x6000018d9180 objStrong:0x6000018d9180 objCopy:0x6000018d9160 可以看到指向的是堆中两块不同的内存,其中\bobjStrong指向的内存地址与obj的相同。换句话说，strong修饰的属性没有开辟新的内存空间。而copy修饰的属性开辟了新的内存空间。在属性\b不希望被外部修改的时候，我们可以用copy来修饰。原因如上例子所述。 二、从源码看strong的底层原理（备注 我看的版本是objc4-723）在NSObject.mm line294中可以看到以下代码12345678910objc_storeStrong(id *location, id obj)&#123; id prev = *location; if (obj == prev) &#123; return; &#125; objc_retain(obj); *location = obj; objc_release(prev);&#125; \b\b首先判断和之前的引用是否相同\b\b若不同，往下执行，retain obj并\b释放之前的引用（旧的引用对象rc–） 三、copy\b在objc-runtime-new.mm line 621912345678910111213141516171819202122_object_copyFromZone(id oldObj, size_t extraBytes, void *zone)&#123; if (!oldObj) return nil; if (oldObj-&gt;isTaggedPointer()) return oldObj; // fixme this doesn't handle C++ ivars correctly (#4619414) Class cls = oldObj-&gt;ISA(); size_t size; id obj = _class_createInstanceFromZone(cls, extraBytes, zone, false, &amp;size); if (!obj) return nil; // Copy everything except the isa, which was already set above. uint8_t *copyDst = (uint8_t *)obj + sizeof(Class); uint8_t *copySrc = (uint8_t *)oldObj + sizeof(Class); size_t copySize = size - sizeof(Class); memmove(copyDst, copySrc, copySize); fixupCopiedIvars(obj, oldObj); return obj;&#125; 可以看到这句1id obj = _class_createInstanceFromZone(cls, extraBytes, zone, false, &amp;size);","categories":[],"tags":[]},{"title":"设计一个合理的蓝牙框架","slug":"设计一个合理的蓝牙框架","date":"2018-11-25T16:47:05.000Z","updated":"2019-05-01T10:14:27.304Z","comments":true,"path":"2018/11/26/设计一个合理的蓝牙框架/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/设计一个合理的蓝牙框架/","excerpt":"","text":"蓝牙：为方便接入特定协议下的设备，有必要对硬件设备进行抽象，将蓝牙通讯的过程、逻辑封装成Framework。调用者不要花时间分析芯片的协议、特性，只需要拿到Framework，调用API即可。基于以上前提，这个框架需要具备以下条件： 指令响应及时、不需要调用者进行各种判断（比如设备是否断开、设备是都需要重连、指令是否需要重发、指令发送超时） 能直接将数据封装好给调用者使用。 指令有优先级。调用者可以设定指令优先级。（如调用者将“升级指令”设为最优，则处理完此次指令之前，其他指令都在等待序列） 由于底层会将数据分成以20bytes为单位进行读取。所以客户端要对收到的数据包进行合包。合包规则参照协议中包的结构，脏数据要及时丢弃。客户端向蓝牙端发送数据时也要进行分包，并且根据芯片的性能，添加一定的延时，具体时长参照芯片的处理时间。除非必要，不进行频繁的断开、重连操作。","categories":[],"tags":[]},{"title":"几种变量类型","slug":"几种变量类型","date":"2018-11-25T16:23:24.000Z","updated":"2019-05-06T12:53:07.326Z","comments":true,"path":"2018/11/26/几种变量类型/","link":"","permalink":"http://blog.kaolagogogo.fun/2018/11/26/几种变量类型/","excerpt":"","text":"1. 全局变量： 要在函数外面声明 可以跨文件访问 声明时可以赋值 默认初始值为0 储存在【全局（静态）存储区static】 extern 关键字 extern varName代表的是varName是调用\b外部声明的变量 2. 静态变量 可以在函数外部声明、亦可在函数外部声明 仅在\b声明文件内访问、不可以改变局部变量的作用域 声明时关键字为static 声明时可以赋值 默认初始值为0 储存在【全局（静态）存储区static】、只有一份内存 可以延长变量的生命周期 3. 局部变量 要在函数内部声明 \b运行到该函数时才会分配\b内存 只在\b声明变量的函数内部访问 一般数据类型储存在栈帧中，new init开头的方法初始化的对象储存在堆上。 4. const关键字 修饰关键字右边的变量 修饰后变量为只读 场景🌰：提供一个方法，放入参数是某个变量的地址，方法内部不能修改地址（在诸多Foundation框架提供的API中可以看到这个场景的应用）5. 内存分区 栈区： 堆区： 全局区： 文字常量区 程序代码区 题外话结合看过的博客，自己在实践的过程当中发现，NSString 比较特殊，并不完全如其他对象，是分配在堆区的。 update：在objc的源码中经常可以看到isTargetPointer这样的判断，由此知道了NSTargetPointer这样的特殊类型，笔记请看[NSTargetPointer]","categories":[],"tags":[]}]}