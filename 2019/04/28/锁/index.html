<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>锁 | KAOLA's note</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">锁</h1><a id="logo" href="/.">KAOLA's note</a><p class="description">fix it</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">锁</h1><div class="post-meta">Apr 28, 2019<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2019/04/28/锁/" href="/2019/04/28/锁/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><ol>
<li>自旋锁(spinlock) do while 、忙等、（理解成死循环等锁 因此不适合较长时间的任务，等待的过程非常耗CPU）</li>
<li>互斥锁(mutexlock) 休眠状态等锁</li>
<li>读写锁(rwlock)：处于“写锁”时任何操作都要休眠等锁</li>
<li>递归锁(recursivelock)：是互斥锁的一个特例 允许同一个线程在未释放拥有的锁时反复对该锁进行加锁操作</li>
<li>死锁 一个资源被多次调用，而多次调用方都未能释放该资源就会造成一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死 锁状态或系统产生了死锁。</li>
</ol>
<ol>
<li><p>@synchronized 关键字加锁<br> 用法简洁、可读性强：传入对象即可，没有显示的添加锁、释放锁代码</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="comment">// do work </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 杨肖玉的博客中翻译了国外大神的文章并做了详细的解释，对下面的问题有很详细的解读，博客地址：<a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/</a></p>
<ol>
<li>锁是如何传入@synchronized的对象关联上的?</li>
<li><p>如果传入@synchronized的对象在@synchronized的block里面被释放或者被赋值为nil会怎样?</p>
<p>下面是阅读完博客后的笔记。</p>
<p>首先 apple文档中有一段话：（地址：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3）" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3）</a><br>As a precautionary measure, the @synchronized block implicitly adds an exception handler to the protected code. This handler automatically releases the mutex in the event that an exception is thrown. This means that in order to use the @synchronized directive, you must also enable Objective-C exception handling in your code. If you do not want the additional overhead caused by the implicit exception handler, you should consider using the lock classes.<br>其中<code>the @synchronized block implicitly adds an exception handler to the protected code</code> 意思是@synchronized为代码块为隐式地添加了一个异常处理。</p>
<p><code>@synchronized</code> block 会变成 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 的成对儿调用<br>可以理解成上面的代码转化成了下面这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="comment">// do work </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        objc_sync_enter(obj);</span><br><span class="line">        <span class="comment">// do work</span></span><br><span class="line">    &#125; <span class="keyword">@finally</span> &#123;</span><br><span class="line">        objc_sync_exit(obj);    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="源码探究-最新源码地址：https-opensource-apple-com-source-objc4-objc4-750-runtime-objc-sync-mm-auto-html"><a href="#源码探究-最新源码地址：https-opensource-apple-com-source-objc4-objc4-750-runtime-objc-sync-mm-auto-html" class="headerlink" title="源码探究  最新源码地址：https://opensource.apple.com/source/objc4/objc4-750/runtime/objc-sync.mm.auto.html"></a>源码探究  最新源码地址：<a href="https://opensource.apple.com/source/objc4/objc4-750/runtime/objc-sync.mm.auto.html" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/objc4-750/runtime/objc-sync.mm.auto.html</a></h2><p><code>&lt;objc/objc-sync.h&gt;</code>中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> alignas(CacheLineSize) SyncData &#123;</span><br><span class="line">    <span class="keyword">struct</span> SyncData* nextData;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class="line">    int32_t threadCount;  <span class="comment">// number of THREADS using this block</span></span><br><span class="line">    recursive_mutex_t mutex;</span><br><span class="line">&#125; SyncData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lockCount;  <span class="comment">// number of times THIS THREAD locked this block</span></span><br><span class="line">&#125; SyncCacheItem;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SyncCache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> allocated;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> used;</span><br><span class="line">    SyncCacheItem list[<span class="number">0</span>];</span><br><span class="line">&#125; SyncCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Fast cache: two fixed pthread keys store a single SyncCacheItem. </span></span><br><span class="line"><span class="comment">This avoids malloc of the SyncCache for threads that only synchronize </span></span><br><span class="line"><span class="comment">a single object at a time.</span></span><br><span class="line"><span class="comment">SYNC_DATA_DIRECT_KEY  == SyncCacheItem.data</span></span><br><span class="line"><span class="comment">SYNC_COUNT_DIRECT_KEY == SyncCacheItem.lockCount</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> SyncList &#123;</span><br><span class="line">    SyncData *data;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line"></span><br><span class="line">    constexpr SyncList() : data(<span class="literal">nil</span>), lock(fork_unsafe_lock) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class="line"><span class="meta">#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#define LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></table></figure>
<p><code>SyncList</code>可以看成是一个链表（key是对象地址的hash值），<code>SyncData</code>是链表中的某个节点。<br><code>SyncData</code>包括了<code>object</code>（就是我们传入的对象）、<code>nextData</code>（链表中的下一个节点）、<code>recursive_mutex_t</code>类型（递归锁）的<code>mutex</code>（与之关联的一个互斥锁）、<code>threadCount</code>（被使用的线程的数量） </p>
<p><code>objc_sync_enter</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> objc_sync_enter(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先回答如果obj为nil的情况 ：<code>@synchronized(nil) does nothing</code><br><code>objc_sync_nil</code> 什么也不做</p>
</li>
<li><p>obj不为空： 调用<code>id2data</code>取出obj对应的SyncData，判断之后进行加锁操作<br><code>objc_sync_exit</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> objc_sync_exit(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>惯例回答 如果代码执行完是，obj为nil： <code>@synchronized(nil) does nothing</code></p>
</li>
<li><p>obj不为空： 调用<code>id2data</code>取出obj对应的SyncData，判断之后进行解锁操作<br>那么<code>id2data</code>在传入了<code>obj</code> 加锁解锁时，函数内部具体做了什么呢？<br><code>id2data</code>代码比较长，为了方便阅读，直接将笔记写在里面</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SyncData* id2data(<span class="keyword">id</span> object, <span class="keyword">enum</span> usage why)</span><br><span class="line">&#123; </span><br><span class="line">    </span><br><span class="line">    spinlock_t *lockp = &amp;LOCK_FOR_OBJ(object);<span class="comment">//lockp指向SyncList对象中的自旋锁</span></span><br><span class="line">    SyncData **listp = &amp;LIST_FOR_OBJ(object);<span class="comment">//listp指向SyncList链表 </span></span><br><span class="line">    SyncData* result = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//对于同一个线程来说，有两种缓存方式：</span></span><br><span class="line">    <span class="comment">//第一种：快速缓存（fastCache），适用于一个线程一次只对一个对象加锁的情况，用宏SUPPORT_DIRECT_THREAD_KEYS来标识</span></span><br><span class="line">    <span class="comment">//这种情况意味着同一时间内，线程缓存中只有一个SyncCacheItem对象，键值SYNC_DATA_DIRECT_KEY和SYNC_COUNT_DIRECT_KEY分别对应SyncCacheItem结构体中的SyncData对象和lockCount.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="comment">// Check per-thread single-entry fast cache for matching object </span></span><br><span class="line">    <span class="comment">// 用于标识当前线程的是否已使用fastCache</span></span><br><span class="line">    <span class="keyword">bool</span> fastCacheOccupied = <span class="literal">NO</span>;</span><br><span class="line">    SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);<span class="comment">//获取syncdata</span></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        fastCacheOccupied = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//标识fastcache被使用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;object == object) &#123;</span><br><span class="line"><span class="comment">//判断fastcache中SyncData中的object与当前的对象是否一致</span></span><br><span class="line"><span class="comment">// Found a match in fast cache.</span></span><br><span class="line">            uintptr_t lockCount;</span><br><span class="line"></span><br><span class="line">            result = data;</span><br><span class="line">            lockCount = (uintptr_t)tls_get_direct(SYNC_COUNT_DIRECT_KEY);<span class="comment">//获取当前线程中SyncData对象已经加锁的次数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"id2data fastcache is buggy"</span>);<span class="comment">//对象发生错误</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span>(why) &#123;<span class="comment">//判断当前的操作是加锁还是解锁</span></span><br><span class="line">            <span class="keyword">case</span> ACQUIRE: &#123;<span class="comment">//加锁 然后更新</span></span><br><span class="line">                lockCount++;</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="keyword">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:<span class="comment">//解锁 </span></span><br><span class="line">                lockCount--;</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="keyword">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">if</span> (lockCount == <span class="number">0</span>) &#123;<span class="comment">//如果lockCount为零 </span></span><br><span class="line">                    <span class="comment">// remove from fast cache</span></span><br><span class="line">                    <span class="comment">//将对应的SyncData对象从线程缓存中移除</span></span><br><span class="line">                    tls_set_direct(SYNC_DATA_DIRECT_KEY, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    <span class="comment">//原子操作 确保线程安全</span></span><br><span class="line">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">                    <span class="comment">//threadCount是多个线程共享的变量，用于记录对一个对象加锁的线程个数，threadCount对应的SyncData对象除了线程缓存中持有之外，还存在于全局哈希表sDataLists中，sDataLists哈希表是多个线程共享的数据结构，因此存在多线程访问的可能，因此需要加锁；而lockCount则与线程一一对应且存储在线程的缓存区中，不存在多线性读写问题，因此不需要加锁</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">    <span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">    <span class="comment">//这是第二种缓存方式：使用SyncCache结构体来维护一个SyncCacheItem数组，这样一个线程就可以处理对多个同步对象。值得注意的是SyncCache与线程也是一对一的关系。</span></span><br><span class="line"></span><br><span class="line">    SyncCache *cache = fetch_cache(<span class="literal">NO</span>);</span><br><span class="line">    <span class="comment">//获取当前线程缓存区中的SyncCache对象</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//遍历SyncCache对象中的SyncCacheItem数组，匹配当前同步对象object</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;used; i++) &#123;</span><br><span class="line">            SyncCacheItem *item = &amp;cache-&gt;list[i];</span><br><span class="line">            <span class="keyword">if</span> (item-&gt;data-&gt;object != object) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a match. 匹配到了</span></span><br><span class="line">            result = item-&gt;data;</span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  item-&gt;lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"id2data cache is buggy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">switch</span>(why) &#123; </span><br><span class="line"><span class="comment">//同上fast-cache一样</span></span><br><span class="line">            <span class="keyword">case</span> ACQUIRE:</span><br><span class="line">                item-&gt;lockCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                item-&gt;lockCount--;</span><br><span class="line">                <span class="keyword">if</span> (item-&gt;lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                    cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used];</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread cache didn't find anything.</span></span><br><span class="line">    <span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line">    <span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line">    <span class="comment">// locks for the same new object.</span></span><br><span class="line">    <span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line">    <span class="comment">// more than 20 or so distinct locks active, but we don't do that now.</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果当前线程中的缓存中没有找到当前同步对象对应的SyncData对象，则在全局哈希表中查找</span></span><br><span class="line"><span class="comment">//因为全局哈希表是多个线程共享的数据结构，因此需要进行加锁处理</span></span><br><span class="line">    lockp-&gt;lock();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//遍历当前同步对象obejct在全局哈希表中的SyncData链表。这里之所以使用链表，是因为哈希表的hash算法不能确保hash的唯一性，存在多个对象对应一个hash值的情况。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;object == object ) &#123;<span class="comment">//匹配到了</span></span><br><span class="line">                result = p;</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">                OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);<span class="comment">//原子操作 </span></span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )<span class="comment">//标记空闲对象</span></span><br><span class="line">                firstUnused = p;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line"><span class="comment">//由于此时同步对象object没有对应的SyncData对象，因此RELEASE与CHECK都属于无效操作</span></span><br><span class="line">        <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// an unused one was found, use it</span></span><br><span class="line"><span class="comment">//如果没有找到匹配的SyncData对象且存在空闲的SyncData对象，则直接使用，不需要创建新的SyncData，以提高效率。</span></span><br><span class="line">        <span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            result-&gt;object = (objc_object *)object;</span><br><span class="line">            result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a new SyncData and add to list.</span></span><br><span class="line">    <span class="comment">// XXX allocating memory with a global lock held is bad practice,</span></span><br><span class="line">    <span class="comment">// might be worth releasing the lock, allocating, and searching again.</span></span><br><span class="line">    <span class="comment">// But since we never free these guys we won't be stuck in allocation very often.</span></span><br><span class="line"><span class="comment">//新建一个SyncData对象</span></span><br><span class="line"></span><br><span class="line">    posix_memalign((<span class="keyword">void</span> **)&amp;result, alignof(SyncData), <span class="keyword">sizeof</span>(SyncData));</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    new (&amp;result-&gt;mutex) recursive_mutex_t(fork_unsafe_lock);</span><br><span class="line">    result-&gt;nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line">done:</span><br><span class="line"><span class="comment">//对全局哈希表的操作结束，解锁</span></span><br><span class="line">    lockp-&gt;unlock();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">        <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">        <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">        <span class="keyword">if</span> (why == RELEASE) &#123;</span><br><span class="line">            <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">            <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;object != object) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">        <span class="keyword">if</span> (!fastCacheOccupied) &#123;</span><br><span class="line">            <span class="comment">// Save in fast thread cache</span></span><br><span class="line">            <span class="comment">//直接缓存新建的SyncData对象</span></span><br><span class="line">            tls_set_direct(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">            tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = fetch_cache(<span class="literal">YES</span>);</span><br><span class="line">            cache-&gt;list[cache-&gt;used].data = result;</span><br><span class="line">            cache-&gt;list[cache-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line">            cache-&gt;used++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>dispatch_once 单例常用dispatch_once来保证某个单例<br> 用法简洁 适用于只执行一次任务的场景<br> 源码:<br> once.h 地址： <a href="https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/dispatch/once.h.auto.html" target="_blank" rel="noopener">https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/dispatch/once.h.auto.html</a><br> once.c 地址：<a href="https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/src/once.c.auto.html" target="_blank" rel="noopener">https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/src/once.c.auto.html</a><br> Q:dispatch_once是如何保证任务只执行一次的？<br> dispatch_once的用法：</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;predicate, ^&#123; </span><br><span class="line">    <span class="comment">// one time task</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSLock</p>
</li>
</ol>
<ol start="3">
<li>NSCondition</li>
</ol>
<ol start="4">
<li>NSConditionLock</li>
<li>NSRecursiveLock</li>
<li>pthread_mutex</li>
<li>dispatch_semaphore 信号量</li>
<li>dispatch_async_barrier 读写锁</li>
<li>OSSpinLock</li>
<li>pthread_rwlock</li>
<li>POSIX Conditions</li>
<li>os_unfair_lock</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.kaolagogogo.fun/2019/04/28/锁/" data-id="cjv52oltp000amjxlprr7o9ip" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2018/11/26/weak/" class="next">weak</a></div><div id="disqus_thread"><script>var disqus_shortname = 'louchu0604';
var disqus_identifier = '2019/04/28/锁/';
var disqus_title = '锁';
var disqus_url = 'http://blog.kaolagogogo.fun/2019/04/28/锁/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//louchu0604.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://blog.kaolagogogo.fun"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/28/锁/">锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/weak/">weak</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/iOS事件响应链/">iOS事件响应链</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/catogory的几个问题/">关于catogory的几个问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/app启动过程/">app启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/做用户轨迹追踪时的思考/">做用户轨迹追踪时的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/自动释放池的原理/">自动释放池的原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/消息转发/">消息转发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/深入比较strong和copy两种修饰符/">深入比较strong和copy两种修饰符</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/设计一个合理的蓝牙框架/">设计一个合理的蓝牙框架</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//louchu0604.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://git.oschina.net/Chu_Lou" title="Git地址" target="_blank">Git地址</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">KAOLA's note.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>