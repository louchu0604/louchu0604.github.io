
三次握手
1. 

http与https的区别

https在http的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份。

具体的步骤是
1. 客户端使用https的URL请求服务器
2. 服务器收到请求后发送网站的证书信息（里面有公钥）
3. 客户端验证有效性
   3.1 对证书中的（网站的公钥、组织名、证书机构、证书的有效期）Hash后生成一串消息摘要
   3.2 证书中的数字签名用发过来的公钥解密
   3.3 比较1和2的结果是否一致
    
4. 客户端将会话密钥用公钥加密后发送
5. 服务器用私钥解密出会话密钥
6. 用会话蜜月加密通信

get post的区别
* get把参数包裹在URL中，post通过request body传递参数
* get的参数有长度限制，post没有限制
其他
DELETE：删除指定的资源 
OPTIONS：返回服务器支持的HTTP方法
PUT：上传指定的URI
状态码：
 1** 用于指定客户端（临时）响应相应的某些动作
* 100  继续  
* 101  交换协议
2**表示请求成功
* 200  OK  
* 201  已创建  
* 202  接收  Accepted 供处理的请求已被接受，但是处理未完成。
* 203  非认证信息  （Non-authoritative Information）
* 204  无内容  （No Content）
* 205  重置内容 （Reset Content） 
* 206  部分内容 （Partial Content）


3**用于重定向
* 300  多路选择  
* 301  永久转移  
* 302  暂时转移  
* 303  参见其它  
* 304  未修改（Not Modified）  
* 305  使用代理 


4**表示客户端错误：
* 400  错误请求（Bad Request）  
* 401  未认证 （Unauthorized） 被请求的页面需要用户名和密码。 
* 402  需要付费 （Payment Required） 
* 403  禁止（Forbidden）  
* 404  未找到（Not Found）  
* 405  方法不允许 （Method Not Allowed）　
* 406  不接受  （Not Acceptable）
* 407  需要代理认证  （Proxy Authentication Required）
* 408  请求超时  （Request Timeout）
* 409  冲突  （Conflict）
* 410  失败  （Gone）
* 411  需要长度  （Length Required）"Content-Length" 未被定义。如果无此内容，服务器不会接受请求。
* 412  条件失败  
* 413  请求实体太大

5**表示服务端错误
* 500  服务器内部错误  
* 501  未实现（Not Implemented）  
* 502  网关失败  
* 504  网关超时  
* 505 HTTP版本不支持


多线程
进程：资源分配的基本单位
线程：程序执行时的最小单位，是进程的一个执行流，线程间可以共享进程的所有资源。
多线程的实现方式：NSOperation、GCD、NSThread
NSOperation的优点：1.添加任务依赖 2.任务执行状态的控制 3.控制最大并发量（maxConcurrentOperationCount）


GCD的优点 ：可读性高
GCD手动创建的线程用完之后需要手动释放（CF开头的）

电量优化：先分析耗电的原因。然后根据CPU 、IO操作、网络、图形、动画、定位等方面进行优化。

弱引用表

APP卡顿的原因：
1. 复杂的UI 图文混排的绘制量过大
2. 主线程做网络同步请求
3. 在主线程做两大的IO操作
4. 运算量过大，CPU持续高占用
5. 死锁和子线程强锁
APP奔溃的原因：
1. KVO的问题：添加和移除次数补一次 未移除的观察者给被释放的属性发消息
2. NSNotification线程问题
3. 数组越界
4. 野指针
5. 后台任务超时 
6. 内存爆了
7. 主线程卡顿超出阈值
8. 找不到方法
推送机制（非第三方库，说清楚原理，websoket长链接）
1.  申请通知权限 获取相应的deviceToken（设备向apns发送注册请求，apns会返回devicetoken）
     1. iOS向APNs远程推送服务器发送app的bundleID和设备的UDID
     2. APNs根据设备的UDID和APP的BundleID生成deviceToken再发回给app
2.  客户端将devicetoken上传至我们的后台服务器，后台服务器接收并储存
3.  后台服务器向apns发送推送
4.  apns根据devicetoken发送到对应的设备上

离屏渲染：在当亲屏幕缓冲区以外开辟一个缓冲区进行渲染
缺点 消耗性能 造成界面卡顿
原因 1. 创建新的缓冲区 2. 需要切换上下文
    3. 由于垂直同步机制 在一个HSync时间内 CPU或者GPU没有完成内容提交 该帧会被丢弃
哪些操作会触发
1. mask shadow opacity 抗锯齿 光栅化
什么是光栅化：将图转为一个一个栅格组成的图像 缓存后可直接复用 减少渲染 （经常变动的内容不要开启 否则会造成性能的浪费）

界面渲染的过程：
UIView的layer层有一个content，指向一块缓存，即backingstore，
UIView绘制时，会调用drawRect方法，通过context将数据写入backingStore
在backingStore写完后 通过render server交给GPU渲染 将backingStore中的bitmap数据显示在屏幕上。
图片加载的步骤：
1. 从磁盘拷贝数据到内核缓冲区
2. 从内核缓冲区复制数据到用户空间
3. 生成uiimageview 把图像数据赋值给uiimageview
4. 如果图像数据未解码的png或jpg 解码为位图数据
5. CATransaction捕获uiimageview layer树的变化
6. 主线程runloop提交CATransaction 开始进行图像渲染

CATransaction是 Core Animation 中的事务类，在iOS中的图层中，图层的每个改变都是事务的一部分，CATransaction可以对多个layer的属性同时进行修改，同时负责成批的把多个图层树的修改作为一个原子更新到渲染树。
CATransaction事务类分为隐式事务和显式事务，注意以下两组概念的区分：
1.隐式动画和隐式事务:
隐式动画通过隐式事务实现动画 。
2.显式动画和显式事务:
显式动画有多种实现方式，显式事务是一种实现显式动画的方式。

SDWebImage双缓存：采用memory disk双重cache机制
memory cache：AutoPurgeCache 在内存紧张的时候释放缓存（接收系统的内存警告通知）
disk cache：磁盘缓存
1.调用下载图片（sd_setimageWithURL---> downloadImagewithURL）
2. 检查缓存（queryDiskCacheforkey-->imageFromMemoryCacheForKey先查memorycache--->diskImageForKey再查diskcache 如果查到了 放到memorycache中 ）
3. 都没有查到 开始下载图频 
4. 如果下载失败 该url会加入failedURLs
5. 下载成功 soreImagetodisk

Disk缓存清理策略
1. 先清除过期缓存
2. 按文件时间从早到晚开始清理 直到达到要求

如何控制过期文件
1. app进入后台 遍历所有的缓存文件 超过时长的会被删除
2. 使用maxCacheSize控制了最大缓存空间

oc的动态性：
动态类型
动态绑定
动态加载资源 运行时加载新的类 

weak表（weak_table_t）的细节
1. weak_entries * weak_entry_t
    1. referent：被指对象的地址
    2. referrers：弱引用超过四个时存这里
    3. inline_referrers：弱引用不超过四个时存这里
    4. mask;/// 记录当前referrers数组容器的大小
    5. num_refs : PTR_MINUS_1;/// num_refs记录的是实际引用数量
    6. max_hash_displacement;/// 根据hash-key寻找index的最大移动数
2. num_entries 实际使用的数量
3. mask 当前容器大小
4. max_hash_displacement //寻找时的最大移动数

ps 插入的时候采用开放地址法 并记录下最大移动数 寻找的时候如果超过最大移动数 则说明没有找到

weak_entry_t扩容：扩容时机是使用的数量超过mask的3/4
1.大小增长一倍
2. 旧的数据复制到新的entry中
3. 插入新的弱引用
4. 释放旧的数据

为什么弱引用采用两种结构来储存（referrers和inline_referrers）：数据多了之后 数组的查找难度会增加

weak_table_t扩容：扩容时机是使用的数量超过mask的3/4




AFN2.0 AFN3.0 源码阅读笔记
说明：只看了网络通信模块的代码，其他模块的还没有开始看
问题
1. 2.0中为什么需要有一个常驻线程
2. 3.0中为什么不需要常驻线程
##2.0 
NSURLConnection 是异步发送的  任务完成后要通知原来线程的runloop去回调complete等事件（要在同一个线程处理回调）
做法有
1. 放到主线程（会收到runloop模式的影响）
2. 一个请求一个线程 （开销太大 ）
3. 一个专门的线程 
总结：AFN2.0 NSURLConnection首先需要在子线程去start connection，请求发送后，所在的子线程需要保活以保证正常接收到 NSURLConnectionDelegate 回调方法。如果每来一个请求就开一条线程，并且保活线程，这样开销太大了。所以只需要保活一条固定的线程，在这个线程里发起请求、接收回调。

NSURLConnection：

NSURLSession：
NSURLSession发起的请求，不再需要在当前线程进行代理方法的回调！可以指定回调的delegateQueue，
串行回调的原因是为了数据安全（否则容易造成数据混乱）

tcp笔记
tcp报文的结构
每个字段的作用

三次握手和四次回收
拥塞控制
ios 自动化打包
你用过哪些锁
MVVM
函数式编程
排序


