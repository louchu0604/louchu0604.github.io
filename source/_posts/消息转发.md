---
title: 消息转发
date: 2018-11-26 00:48:54
tags: objc
---
# Background or Question
1. 一般给对象的属性赋值主要有两种方式， `_var=newValue` 和 `objc.var = newValue`，大家都知道前者效率高，后者效率低
2. 开发的过程中，引起APP奔溃的叫常见的一个场景是`unRecognizedSelector`，顾名思义是无法识别的方法or选择子
3. 经常会有人问一个很宏观的问题：你是如何理解`runtime`的，我觉得`runtime` 有两个角度可以解释
* 一套用c实现的底层API 源码可以在apple的source library里下载
* 一种动态运行机制
* 在iOS中，程序运行时调用的方法【or 消息】并不是编译时期就确定下来的，可以在运行时才确定、甚至是修改。
消息转发的机制，也是因为有`runtime`，才能如此设计。




# how 

在源码里找了一下对应的实现
`forwardInvocation`的调用栈：
* `forwardInvocation`
* `doesNotRecognizeSelector`
* `_objc_fatal`
写了一个很简单的demo来模拟了一下：

```objc
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    [self sendMsg];
    // Do any additional setup after loading the view, typically from a nib.
}
- (void)sendMsg
{
    [self performSelector:@selector(hello)];
}
@end

```
ViewController这个类并没有实现`hello`
这个场景很熟悉，如果没有预防措施的话，会抛出`unrecognized selector sent to instance XXX`
### 根据消息发送、转发的流程，大概有以下三种方法
#### ① 在分类中重写`resolveInstanceMethod` 动态添加方法
```objc
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    NSString *clsStr = NSStringFromSelector(sel);
    if ([clsStr isEqualToString:@"hello"]) {
       class_addMethod([self class], sel, (IMP)mymethod, "v@:@");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}

void mymethod(id self, SEL _cmd){
     NSLog(@"hello method added");
}
```
#### ② `forwardingTarget` 转发
```objc
- (id)forwardingTargetForSelector:(SEL)aSelector
{
    NSString *clsStr = NSStringFromSelector(aSelector);
    if ([clsStr isEqualToString:@"hello"]) {
        return [TestObj new];
    }
    return nil;
}
```
在TestObj中实现了：
```objc
- (void)hello
{
    NSLog(@"found hello");
}

```
#### ③ `forwardInvocation` 转发
```objc
- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    NSString *clsStr = NSStringFromSelector(anInvocation.selector);

    if ([clsStr isEqualToString:@"hello"])
    {
        [anInvocation invokeWithTarget:[TestObj new]];
    }
}
-(NSMethodSignature*)methodSignatureForSelector:(SEL)selector
{
    NSMethodSignature *signature = [super methodSignatureForSelector:selector];
    if (! signature) {
        signature = [[TestObj new] methodSignatureForSelector:selector];
    }
    return signature;
}
```
跟②相似，③也是将消息转发给备用接收者。

# 我的困惑
`forwardingTarget`和`forwardInvocation`在本来找不到对应的方法时，可以将消息转发给可以其他对象，那他们的区别是什么？