疑问：`forwardingTarget`和`forwardInvocation`在本来找不到对应的方法时，可以将消息转发给可以其他对象，那他们的区别是什么？
在源码里找了一下对应的实现
`forwardInvocation`的调用栈：
* `forwardInvocation`
* `doesNotRecognizeSelector`
* `_objc_fatal`
写了一个很简单的demo来模拟了一下：

```objc
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    [self sendMsg];
    // Do any additional setup after loading the view, typically from a nib.
}
- (void)sendMsg
{
    [self performSelector:@selector(hello)];
}
@end

```
ViewController这个类并没有实现`hello`
这个场景很熟悉，如果没有预防措施的话，会抛出`unrecognized selector sent to instance XXX`
### 根据消息发送、转发的流程，大概有以下三种方法
#### ① 在分类中重写`resolveInstanceMethod` 动态添加方法
```objc
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    NSString *clsStr = NSStringFromSelector(sel);
    if ([clsStr isEqualToString:@"hello"]) {
       class_addMethod([self class], sel, (IMP)mymethod, "v@:@");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}

void mymethod(id self, SEL _cmd){
     NSLog(@"hello method added");
}
```
#### ② `forwardingTarget` 转发
```objc
- (id)forwardingTargetForSelector:(SEL)aSelector
{
    NSString *clsStr = NSStringFromSelector(aSelector);
    if ([clsStr isEqualToString:@"hello"]) {
        return [TestObj new];
    }
    return nil;
}
```
在TestObj中实现了：
```objc
- (void)hello
{
    NSLog(@"found hello");
}

```
#### ③ `forwardInvocation` 转发
```objc
- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    NSString *clsStr = NSStringFromSelector(anInvocation.selector);

    if ([clsStr isEqualToString:@"hello"])
    {
        [anInvocation invokeWithTarget:[TestObj new]];
    }
}
-(NSMethodSignature*)methodSignatureForSelector:(SEL)selector
{
    NSMethodSignature *signature = [super methodSignatureForSelector:selector];
    if (! signature) {
        signature = [[TestObj new] methodSignatureForSelector:selector];
    }
    return signature;
}
```
跟②相似，③也是将消息转发给备用接收者。